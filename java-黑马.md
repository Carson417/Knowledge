# 基础入门 

## 1.  java入门

### 1.1 java的三大技术平台

- Java SE：标准版
- Java EE：企业版
- Java ME：小型版（一般不用）

### 1.2 java名词

- `JVM`：java虚拟机，真正运行java的地方

- 核心类库：java自己写好的程序，给程序员自己调用的
  - API：应用程序编程接口
- `JRE`：java的运行环境
  - JRE  = JVM + 核心类库
- `JDK = JRE + java、javac`

### 1.3 开发程序的入门步骤

#### 1.3.1 安装JDK（java development kit）

- java开发工具包，必须安装 JDK 才能使用java

##### 1.3.1.1 验证安装

```java
// 命令行中
java
javac
java -version
javac -version
```

- java.exe：执行工具
- javac.exe：编译工具
  - 必须先通过编译后，再执行

#### 1.3.2 配置环境变量

- Path环境变量：用于配置程序所在路径
  - 以便在命令行窗口的任意目录下直接通过命令启动该程序
- 建议为 JDK 再配置 JAVA_HOME 环境变量，用于告诉`os`，`jdk`装在哪里
  - path 就可写成：`%JAVA_HOME%\bin`

#### 1.3.3 编写程序 

（1）写一个后缀为`.java`的程序

（2）编译：`javac x.java`，注意名字必须相同

- 会生成 `x.class` 文件
  - 一次编译，处处可用  --- java的跨平台原理

（3）执行：`java x` ，注意此时没有后缀！

### 1.4 开发工具

- IDE（集成开发环境）
  - 集成诸如：`jdk`、编写窗、编译、执行等功能的开发工具
- IDEA快捷键
  - ctrl + D ：复制当前行数据到下一行
  - alt + shift + 上下箭头：上下移动当前行代码
- IDEA导入模块
  - copy后，需要点击file -> new ->  module from existing source
  - module无论是导入还是删除，不是光copy就行了，还要注意关联



## 2. java程序的基本语法

### 2.1 注释

- 单行、多行、文档 

### 2.2 字面量

- 分类：整数、小数、字符、字符串、布尔值、空值、特殊字符

### 2.3 变量

#### 2.3.1 认识变量

- 变量是存储在内存里的一块区域

- 定义格式：数据类型 变量名 = 变量值；

#### 2.3.2 变量里数据的存储原理

- 二进制
  - 十进制转二进制：初二取余法
  - 二进制转十进制：位值×位权再求和
- 为了便于观察和表示二进制，推出了八进制和十六进制
- 开头：二进制0b、八进制0、十六进制0x

### 2.4 数据类型

##### 2.4.1 基本数据类型（4类8种）

###### 2.4.1.1 整型

- `byte（1）、short（2）、int（4）、long（8)`

###### 2.4.1.2 浮点型

- `float（4）、double（8）`

###### 2.4.1.3 字符型

- `char（2）`

###### 2.4.1.4 布尔型

- `boolean（1）`

##### 2.4.2 引用数据类型

### 2.5 关键字

- 编程语言保留的，有特殊意义的词

### 2.6 标识符

- 程序员自定义的名称
- 数字不能做开头！
- 不能包含一些特殊字符如&、%、#

### 2.7 方法

#### 2.7.1 方法是什么

- 一种用于执行特定任务或操作的代码块，代表一个功能，可以接收数据处理，并返回结果

#### 2.7.2 方法的定义和调用

#### 2.7.3 方法的一些注意事项

##### 2.7.3.1 方法可以重载

- 一个类中，出现多个**同名**的方法，但是他们的**形参列表不同**
  - 类型、个数、顺序

##### 2.7.3.2 无返回值的方法中可以直接通过单独的return；立即结束当前方法的执行

### 2.8 类型转换

#### 2.8.1 自动类型转换

- 类型范围小的变量可以直接赋值给类型范围大的变量 --- 不然就越界了

#### 2.8.2 强制类型转换

- 类型范围大的变量需要强制类型转换，才能赋给类型范围小的变量
  - **浮点型强转成整型，会直接丢掉小数部分**

#### 2.8.3 表达式的自动类型提升

- 在表达式中，小范围的会自动转换成大范围的类型，再参与运算
  - 最终结果由最高类型决定
- 在表达式中，<u>byte、short、char是直接转换成`int`类型参与运算的</u>
  - **所以就算byte+byte，返回的也是`int`**

### 2.9 输入输出

输入：通过java提供的Scanner程序实现

```java
//创建扫描器对象
Scanner sc= new Scanner(System.in);

//让程序停在此行，输入后敲回车后，赋值继续
sc.next();				//字符串
sc.next().charAt(0);	//字符
sc.nextInt();
```

### 2.10 运算符

#### 2.10.1 算数运算符、+号做连接符

- / ：两个整数相除的结果还是整数
- +：与字符串运算时，用作连接，结果仍是字符串
  - 能算则算，不能算就连接

```java
int a =5;

"XYZ" + a + 'a'		//XYZ5a
a + 'a' +"XYZ"		//102XYZ
```

#### 2.10.2 自增自减运算符

- 前缀：先对变量±1，再运算
- 后缀：先运算，再对变量±1

#### 2.10.3 赋值运算符

- 扩展赋值运算符：+=、-=、*=、/=、%=
  - <u>扩展赋值运算符隐含了强制类型转换</u>
  - <u>a+=b，强转成**a的类型**，因为最后的结果是要赋给a的类型</u>

#### 2.10.4 关系运算符

- 返回布尔类型的结果：true或false

#### 2.10.5 三元运算符

```java
条件表达式 ？ 值1 ：值2
```

- 条件表达式值为true，结果是值1，false就为值2

#### 2.10.6 逻辑运算符

- 返回布尔类型的结果：true或false
- &&、||相较于&、|的区别：前者会“短路求值”
  - 比如&&：如果第一个值为false，那么直接就是false

### 2.11 随机数

```java
Random r = new Random();
r.nextInt(100)	// 0~99

Math.random();	// [0,1)
```

### 2.12 程序流程控制

#### 2.12.1顺序结构

#### 2.12.2 分支结构

- if
- switch
  - 通过比较值是否相等，决定执行哪条分支
  - <u>表达式类型支持：`byte、short、int、char、String、枚举`</u>
    - <u>不支持double、float、long</u>
      - 不能精准的确定小数
  - case的值只能是常量
  - 注意不要忘记break
    - 多个case代码相同时，可以通过穿透，只写一个case块

#### 2.12.3 循环结构

- for 和 while 在功能上是一样的 ---知道循环几次用for，不知道用while



## 3. 程序中的数据存储数组、二维数组

### 3.1 一维数组

- 数组是一个数据容器，用来存储一批同类型的数据
- **数组名存的是数组的首地址**

#### 3.1.1 静态初始化

```java
String[] names = {"a","b"};
String[] names = new String[]{"a","b"};
```

#### 3.1.2 动态初始化

- 只确定存储的数据类型和长度
- `boolean` 的默认值为 false
- <u>引用类型（类、接口、数组、String）默认值：null</u>

```java
int[] scores = new scores[8]; 	// 长度为8
scores[i] = x;
```

### 3.2 二维数组

- 数组中的每个元素都是一个一维数组

#### 3.2.1 静态初始化

```java
// 数据类型[][] 数组名 = new 数组类型[][]{元素1，元素2，元素3};
int[][] arr = new int[][]{{1,2,3},{4,5}};
```

#### 3.2.2 动态初始化

```java
// 数据类型[][] 数组名 = new 数组类型[长度][长度]
int[][] arr = new int[3][5];
```

#### 3.2.3 访问

```
// 数组名[行索引][列索引]；
```



## 4. 程序中的数据存储：面向对象入门

### 4.1 对象

- 对象是一种数据结构，可以用来记住一个事物的数据，从而代表该事物

- `类名 对象名 = new 类名()；`

------



### 4.2 类

- 对象的模板
- 五大部分：成员变量、构造器、方法、代码块、内部类



#### 4.2.1 构造器

- 创建对象时，对象会调用构造器
  - 创建对象时，同时完成对对象成员变量（属性）的初始化
- 类默认自带一个无参构造器
  - 如果定义了有参构造，那这个默认的无参构造就没有了
  - 如果还想用无参构造，就只能自己手写



#### 4.2.2 this

- tihs就是一个变量，可以用在方法中，**拿到当前对象**
  - <u>哪个对象拿到这个方法，this就指向这个对象，也就是拿到这个对象</u>
  - 拿到的是**对象的地址**
- 应用场景：

（1）解决：变量名冲突问题 ---局部变量和成员变量重名，`this.变量名`代表成员变量 ，即对象的属性



#### 4.2.3 封装

封装的设计规范：合理隐藏，合理暴漏

- private 修饰成员变量 ---成员变量只能在本类中被直接访问，其他地方都不能被访问
- 在类内提供一个类外可以访问私用属性的公共函数
  - public 修饰的 get 和 set 方法



#### 4.2.4 javabean（实体类）

- 是一种特殊类
  - 所有成员变量均为 private，提供public 的 get 和 set 方法
  - 类中需要提供一个无参构造器，有参构造器可选

- 作用：创建对象，存储数据
- 应用场景：<u>实体类的对象只负责存储数据，而对数据处理的业务交给其他类的对象完成</u>，实现数据和业务的分离

```java
@Data
public class Student(){
	private String name;
}

puvlic class StudentOperator(){
	private Student s;
    
    public StudentOperator(){
	}
    public StudentOperator(Student s){
		this.s = s;
    }
    
    public void print(){
        sout("s.getName()");
    }
}
```



#### 4.2.5 static

静态，修饰成员变量，成员方法 

##### 4.2.5.1 static 修饰成员变量

- 成员变量按照有无 static 修饰分为

1. 静态变量（类变量）
   - **属于类的，与类一起加载一次，只有一份，被类的所有对象共享**
   - 访问：`类名. 静态变量`
     - `对象.静态变量`也可以，但不推荐
2. 实例变量（对象的变量）
   - **每个对象都有一份**
   - 访问：`对象. 实例变量`

- 使用场景：某数据只需要一份，并希望能被共享（访问，修改 ）
- <u>**同一个类中，访问静态变量，类名可以不写**</u> ---访问其它类中的静态变量必须带类名

##### 4.2.5.2 static 修饰成员方法

- 分类

1. 静态方法
   - **属于类**
   - 访问：`类名. 静态变量`
     - `对象.静态变量`也可以，但不推荐
2. 实例方法
   - **属于对象**
   - 访问：`对象. 实例变量`

- 如果这个方法<u>只是为了实现一个功能，且不需要直接访问对象的数据</u>，可以定义成静态方法 ---比如 printHello
  - 如果这个方法是对象的行为，需要访问对象的数据，必须写成实例方法

```java
public static void printHello(){
    sout("hello");
}

public void setAge(int age){
    this.age = age;
}
```

- <u>**同一个类中，访问静态方法，类名可以不写**</u> ---访问其它类中的静态方法必须带类名

##### 4.2.5.3 静态方法的应用

- 工具类
  - 工具类中的方法都是静态方法，一个方法一个功能，方便开发人员直接使用
  - <u>工具类没有创建对象的需求，建议将构造器私有</u>  --- 类外就不能 new 对象了
    - 实例方法需要创建对象，占用内存

##### 4.2.5.4 注意事项

- **静态方法可以直接访问静态成员，不可以直接访问实例成员**
  - <u>只能通过创建对象间接访问</u>
- 实例方法既可以直接访问静态成员，又可以直接访问实例成员
- 实例方法中可以有this关键字，**静态方法中不能有this关键字**



## 5. 面向对象高级   

### 5.1 继承

#### 5.1.1 认识继承

- 子类能继承父类的**非私有**成员（变量、方法）
  - <u>子类对象的实际内存布局中是有父类私有成员的，但是不能直接访问</u>

- 子类对象由子类和父类共同创建

#### 5.1.2 权限修饰符

限制类中成员（变量、方法、构造器）的访问范围

|  修饰符   | 本类 | 同一个包中的类 | 子类 | 任意位置 |
| :-------: | :--: | :------------: | :--: | :------: |
|  private  |  √   |                |      |          |
|  default  |  √   |       √        |      |          |
| protected |  √   |       √        |  √   |          |
|  public   |  √   |       √        |  √   |    √     |

#### 5.1.3 继承的特点

##### 5.1.3.1 单继承

一个类只能继承一个直接父类

##### 5.1.3.2 多层继承

java 不支持多继承，但支持多层继承

##### 5.1.3.3 祖宗类

java 中所有类都是 Object类的子类

##### 5.1.3.4 就近原则

<u>优先访问自己类中，自己类中没有才访问父类</u> ---自己类中也是先局部范围找，再子类成员范围找

- 必须要父类的话，使用 super 关键字

```java
class Father{
    String name = "father";
}
class Son{
    String name = "son";
    
    public show(){
        String name = "name";
        // name
        sout(name);
        // son
        sout(this.name);
        // father
        sout(super.name);
    }
}
```

#### 5.1.4 方法重写

##### 5.1.4.1 注意事项

- 子类重写一个和父类**方法名、参数列表相同**的方法
- `@Override`重写的校验注解：必须方法名、参数列表一致，否则报错
- 重写时，<u>子类的方法的访问权限必须 ≥ 父类该方法的权限</u> （public  > protected > 缺省）
- 重写时，<u>返回类型必须和父类该方法返回类型相同，或者范围更小</u>
  - **私有、静态方法不能被重写**

##### 5.1.4.2 常见场景

1. 重写Object类中的toString()方法，返回对象的内容
   - <u>直接输出对象，会默认调用Object类中的toString()方法，返回对象的地址信息</u>

#### 5.1.5 子类构造器的特点

- 子类全部的构造器都会**先调用父类的构造器，再执行自己**
  - 默认情况，子类构造器的第一行都是 `super( )`，会调用父类无参构造器
  - 如果<u>父类没有无参构造器，必须在子类构造器第一行手写 super(...)，调用父类的有参构造器</u>


```java
public class People{
    private String name;
    private char sex;
    
    public People(){}
    public People(String name, char sex){
        this.name = name;
        this.sex = sex;
    }
}

public class Teacher extends People{
    private String skill;
    
    public Teacher(){}
    public Teacher(String name, char sex, String skill){
        // 把子类继承父类这部分也初始化
        super(name, sex);
        this.skill = skill;
    }
} 
```

#### 5.1.6 this(...)调用兄弟构造器

- 任意类中的构造器，是可以通过this(...) 调用**本类的其他构造器**
- `super(...)、this(...)` **必须写在构造器的第一行，且两者不能同时出现**
  - 因为<u>兄弟构造器也默认有一个super(...)</u>

```java
public class Student{
    private String name;
    private String sex;
    
    public Student(String name){
       	// 调用下面的兄弟构造器
		this(name, "男")；
    }
    public Student(String name, String sex){
        this.name = name;
        this.sex = sex;
    }
}
```



### 5.2 多态

#### 5.2.1 认识多态

- 多态是继承\实现情况下的一种现象，表现为：对象多态、行为多态 

##### 5.2.1.1 多态的前提

- 有**继承的关系，存在父类引用子类对象，存在方法重写**
- 多态是对象、行为的多态，<u>成员变量不谈多态</u>
  - 对方法：<u>编译看**左**边，运行看**右**边</u>
  - 对变量：<u>编译看**左**边，运行看**左**边</u>

```java
public class Animal{
    String name = "动物";
    public void run(){
        sout("动物跑");
    }
}
public class Wolf extends Animal{
	String name = "狼";
    @Override
    public void run(){
        sout("狼跑");
    }
}
public class Cat extends Animal{
	String name = "猫";
    @Override
    public void run(){
        sout("猫跑");
    }
}


Animal a1 = new Wolf();
// 狼跑
a1.run();
// 动物
a1.name;

Animal a2 = new Cat();
// 猫跑
a2.run();
// 动物
a2.name;
```

#### 5.2.2 多态的好处

1. 右边的对象是解耦合的 ---new teacher()，如果不想用了，可以方便的换成 new Student()
2. 定义方法时，可以使用**<u>==父类的形参，可以接收一切子类对象==</u>**

- **<u>多态下不能调用子类独有的功能</u>**
  - 所以需要下节的多态下的类型转换

```java
Animal a1 = new Wolf()；
// wolf里有个方法eat是其独有的
// 那不能 a1.eat()
```

#### 5.2.3 多态下的类型转换

解决调用子类独有功能：

- 自动类型转换：`父类 变量名 = new 子类( )；`
- 强制类型转换：`子类 变量名 = (子类) 父类变量；`

注意：

- 强转在编译时不会报错
- 但是在运行时，如果<u>对象的真实类型和强转后的类型不同</u>，就会报类型转换出错（classCastException)

所以推荐 `instanceof`

- **判断当前对象的真实类型**，之后再强转
  - 在形参为父类时更为有用

------



### 5.3 final

#### 5.3.1 final关键字

- ”最终“

| final 修饰 |          效果          |
| :--------: | :--------------------: |
|     类     |      类不能被继承      |
|    方法    |     方法不能被重写     |
|    变量    | 变量有且仅能被赋值一次 |

- final修饰变量时
  - 基本类型的变量：变量存储的数据不能变
  - 引用类型的变量：<u>变量存储的地址不能变，但是地址指向的对象的内容是可以变的</u>

```java
int[] arr = {1,2,3};
// arr = new int[3],错
arr[0] = 11;
```

#### 5.3.2 常量

- 使用 `static final` 修饰的成员变量称为常量
- 编译后，常量会被”宏替换“，所以使用字面量和常量的性能相同

------



### 5.4 单例类（设计模式）

- **某个类只创建一个对象**
  - 实现

1. 构造器私有
2. 创建类变量记住类的一个对象（唯一对象）
3. 提供一个静态方法返回这个对象

- **饿汉式单例（拿对象时，对象已经创建好了）**

```java
public class A{
    // 创建类变量记住类的一个对象。static确保只有一份
    // 为避免在外很多个A.a，虽然这样也是单例，但是不专业，所以还是private，
    private static A a = new A();
    
    // 私有了，外面才不能new
    private A(){}
    
    public static A getObject(){
        return a;
    }
}
```

- **懒汉式单例（拿对象时，才开始创建对象）**
  - 实现

1. 构造器私有
2. 提供一个静态变量用于存储变量
3. 提供一个静态方法，保证返回的是同一个对象

```java
public class A{
    // null
    private static A a;
    
    private A(){}
    
    public static A getObject(){
        if(a==null){
            a = new A();
        }
        return a;
    }
```

------



### 5.5 枚举类

#### 5.5.1 写法

- 枚举类都是**final**类，不能被继承

- 枚举类的**第一行，只能罗列枚举类的对象名称，并且用逗号隔开**
- 这些名称本质是常量，**每个常量记住了枚举类的一个对象**
- **构造器是私有的**，对外不能创建对象

```java
修饰符 enum 枚举类名{
    名称1，名称2，名称3...；
    其他成员...；
}
```

- 有`values、valueOf` 方法

#### 5.5.2 应用场景

做信息标志和分类，参数值受枚举类的约束

------



### 5.6 抽象类

#### 5.6.1 认识抽象类

abstract，可修饰类和成员方法

- 抽象方法，只有方法签名，没有方法体  ---**没有大括号**

```java
public abstract class A{
    public abstract void test();
}
```

- 抽象类的特点
  - 抽象类中**不一定**有抽象方法，但有抽象方法的一定是抽象类
  - 成员变量、方法、构造器，抽象类都可以有
  - **不能创建对象**，仅作为一种父类，让子类继承并实现
  - 一个类继承抽象类，<u>必须重写所有抽象方法，不然这个类也必须定义为抽象类</u>


#### 5.6.2 使用抽象类的好处

- 更好的支持多态

#### 5.6.3 模板方法设计模式

- 提供一个方法作为完成某类功能的模板
- 模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现
- 建议模板方法用final修饰 ---不能被重写

------



### 5.7 接口

#### 5.7.1 接口概述

interface，定义接口 ---看作“干爹”

- 在jdk8之前，**接口里只能有常量、抽象方法**
  - 可以不写 `public static final`，默认会加上
  - 可以不写 `public abstract`，默认会加上

```java
public interface A{
    成员变量（常量）;
    成员方法（抽象方法）;
}

public class B implements A,C{
    @Override
    ...
}
```

- **接口不能创建对象**
- 接口是用来**被类实现**的，实现接口的类称为**实现类**，<u>一个类可以同时实现多个接口</u>
  - 实现类同样需要重写全部抽象方法，否则需要定义为抽象类

#### 5.7.2 接口好处

1. 弥补单继承的不足，一个类可实现多个接口
2. 面向接口编程，便于切换业务

#### 5.7.3 接口新增的3种方法

- 默认方法：使用default修饰
  - 只能使用接口的实现类对象调用
- 私有方法：jdk9才支持
  - 只能使用<u>接口中的其他方法调用</u>
- 类方法：使用private修饰
  - 只能用接口名调用

注意：**纯public是抽象的，不能写方法体**

```java
public interface A{
	// 默认方法（实例方法），使用default修饰，默认会用public修饰
    // 只能使用接口的实现类对象调用
    default void test1(){
        ...
    }
    
    // 私有方法，jdk9才支持
    private void test2(){
        ...
    }
    
    // 类方法（静态方法），使用private修饰，默认会用public修饰
    // 只能用接口名调用
    static void test3(){
        ...
    }
}
```

#### 5.7.4 接口的注意事项

- 接口与接口可以**多继承**，**一个接口可以同时继承多个接口**
  - <u>一个接口继承多个接口时，如果出现签名冲突，则此时不支持多继承，也不支持多实现</u> ---**更主要的是返回值类型不同**
  - <u>一个类实现多个接口，多个接口中存在同名的默认方法，可以不冲突，类重写方法即可</u> ---接口中是`default`
- 一个类继承父类实现接口，如果有**同名的默认方法，优先使用父类 ** ---儿子离爹亲

```java
interface I{ default void show(){...} }
class C{ public void show(){...} }

class A extends C implements I{
    
  public void goI(){
      show();			// 父类的
      super.show();		 // 父类的
      I.super.show();	 // 接口的
  }
}


interface A1{ default void show(){...} }
interface B1{ default void show(){...} }
class c implements A1,B1{
    @Override
    public void show(){
        A1.super.show();	//A1的
        B1.super.show();	//B1的
    }
}
```

#### 5.7.5 接口和抽象类的区别

- 相同点
  - 都是抽象形式，都可以有抽象方法，都不能创建对象
  - 都是派生子类形式：抽象类被子类继承，接口被实现类实现
  - 都必须重写完他们的抽象方法
  - 都支持多态，都支持解耦
- 不同点
  - 抽象类可以定义类的全部普通成员，接口只能定义常量，抽象方法（JDK8之前）
  - 抽象类只能被类单继承，接口可以被类多实现
  - 一个类继承了抽象类就不能再继承别的类，一个实现类实现了一个接口还能继承其他类或实现其他接口
  - **抽象类体现模板思想：更利于做父类，实现代码复用性**
  - **接口功能更适合功能的解耦合**

------



## 6. Lambda、方法引用、GUI

### 6.1 代码块

静态代码块、实例代码块

#### 6.1.1 静态代码块

- 格式：`static{ ... }`
- 特点：**类加载时自动执行，由于类只加载一次**，所以静态代码块也只执行一次
- 作用：完成类的初始化，如：对<u>静态变量的初始化赋值</u>

#### 6.1.2 实例代码块

- 格式：`{ ... }`
- 特点：**每次创建对象，执行实例代码块，并在构造器前执行**
- 作用：和<u>构造器一样，都是用来完成对象的初始化</u>，例如：对实例变量进行初始化赋值



### 6.2 内部类

- 一个类定义在另一个类的内部，这个类就是内部类

#### 6.2.1 成员内部类

- 就是类中的一个普通成员，类似成员变量
  - **无static修饰，是外部类对象持有的**
  - 创建对象语法：`Outer.Inner oi = new Outer(...).new Inner(...);`

```java
public class Outer{
    public class Inner{
        ...
    }
}

// 创建对象
Outer.Inner oi = new Outer().new Inner();
```

- 成员内部类访问外部类成员的特点
  - **成员内部类可以直接访问外部类的静态成员、实例成员**
  - 成员内部类的实例方法中，可以<u>直接拿到当前寄生的外部类对象</u>：`外部类名.this`
    - this是自己这个类

```java
class People{
    private int heart = 100;
    
    public class inner{
        private int heart = 80;
        
        public void show(){
            int heart = 200;
            
           	// 200
            sout(heart);
            // 80
            sout(this.heart);
            // 100
            sout(People.this.heart);
        }
    }
}
```



#### 6.2.2 静态内部类

- 由`static`修饰的内部类，**属于外部类自己持有**
  - 创建对象语法：`Outer.Inner oi = new Outer.Inner(...);` ---不需要外部类对象再创建
- 静态内部类访问外部类成员的特点
  - **成员内部类可以直接访问外部类的静态成员，但是不可以直接访问实例成员**  ---后者属于对象  ---可以间接访问



#### 6.2.3 局部内部类

- 在方法中、代码块中、构造器中定义的类



#### 6.2.4 匿名内部类

##### 6.2.4.1 认识

- 一种特殊的局部内部类
- 匿名是指：程序员不需要为这个类声明名字，默认有个隐藏的名字

```java
new 类或接口（参数值）{
    类体（一般是方法重写）
}
```

- 本质：子类，并会立即创建一个子类对象
- 作用：更方便的创建子类对象

```java
public abstract class Animal{
    public abstract void cry();
}

// 正常情况
class Cat extends Ainmal{ @Override cry }
Animal a = new Cat();
a.cry();

// 匿名内部类
Animal a = new Animal(){
    @Override
    public void cry(){...}
}
a.cry();
```



##### 6.2.4.2 常见使用形式

- 通常**作为一个对象参数传给方法**

```java
Interface swim{
    void swimming();
}

public static void start(swim s){...}

// 正常
class Student implements swim{
    @Override
    void swimming(){...}
}
swim s = new Student();
start(s);

// 匿名内部类
swim s = new swim(){
    @Override
    void swimming(){...}
}
start(s);

// 更简便
start(new swim(){
    @Override
    void swimming(){...}
});
```

------



### 6.3 函数式编程

- 类似于数学中的函数，只要输入的数据一致，结果也是一致

#### 6.3.1 lambda

- 作用：用lambda代替某些匿名内部类对象
  - 只能简化**函数式接口的匿名内部类**
    - 函数式接口：**有且仅有一个抽象方法的接口**，@FunctionalInterface注解

```java
（被重写方法的形参列表）-> {
    被重写方法的方法体代码
}
```

- lambda表达式省略规则
  - 参数类型可以全部省略不写
  - 如果只有一个参数，参数类型省略的同时，( )括号也可以省，但是多个参数就不能省
  - 如果lambda中只有一行代码，大括号可以不写，；分号也不写，如果这行是return，return也不写



#### 6.3.2 方法引用

##### 6.3.2.1 静态方法引用

- 格式：`类名::静态方法`
  - 相当于 x->f(x)，变成了f
- 使用场景：lambda表达式中，只调用一个静态方法，并且 -> 前后参数形式一致

##### 6.3.2.2 实例方法引用

- 格式：`对象名::实例方法`
  - 相当于 x->f(x)，变成了f
- 使用场景：lambda表达式中，通过对象名调用一个实例方法，并且 -> 前后参数形式一致

##### 6.3.2.3 特定类的方法引用

- 格式：`特定类的名称::方法`
  - 相当于 x->f(x)，变成了f
- 使用场景：lambda表达式中，只是调用一个特定类型的实例方法，并且参数列表中的第一个参数作为方法的主调，后面的所有参数都是作为该实例方法的参数

```java
public int compare(String o1, String o2){
    return o1.compareToIgnoreCase(o2);
}
// 优化
String::compareToIgnoreCase
```

##### 6.3.2.4 构造器引用

- 格式：`构造器::new`
  - 相当于 x->f(x)，变成了f
- 使用场景：lambda表达式中，只是创建对象，并且 -> 前后参数形式一致

------



### 6.4 常用API

#### 6.4.1 String

- String代表字符串，其对象可以封装字符串数据

##### 6.4.1.1 创建字符串对象的方式

1. java程序中所有字符串文字都是此类的对象，String name = "abc";
2. 调用Stirng类的构造器初始化字符串对象

- `public String( )`,`public String(String original)`,`public String(char[] chars)`,`public String(byte[] bytes)`,



#### 6.4.2 ArrayList





### 6.5 GUI编程











## 7. 综合管理系统&java游戏开发





























































# 基础加强

## 异常、范型、集合框架



## Map集合框架、Stream



## 常用API-IO流框架



## 常用API-多线程



## 常用API-网络编程综合项目实战



## 常用API-反射&注解 