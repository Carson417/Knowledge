# 函数式编程-Stream流

## 1.概述

### 1.1 作用

- 大数量下处理集合效率高---并行流

### 1.2 函数式编程思想

- 面向对象思想关注：用什么对象完成什么事
- 函数式编程思想关注：对数据进行了什么操作



## 2.Lambda表达式

### 2.1 概述

- lambda是jdk8的一个语法糖
   - 语法糖：指计算机语言中添加的某种语法，这种语法对于语言的功能没有影响，但是更方便程序员使用
- 对某些匿名内部类的写法简化

### 2.2 核心原则

- 可推导可省略

### 2.3 基本格式

- ==只关注参数和方法体！==
   - **抽象方法的参数**

```java
(参数列表) -> {代码}
```

#### 例一

- 在创建线程并启动时可以使用匿名内部类的写法

```java
new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("新线程中run方法被执行了");
            }
        }).start();
```

- **匿名内部类是一个接口，并且其中只有一个抽象方法需要重写  --- 那就可以lambda简化**
- 他不关注用的是什么对象（Runnable），不关注方法名（run），只关心参数和方法体

```java
new Thread(() -> {
            System.out.println("lambda写法新线程中run方法被执行了");
        }).start();
```

#### 例二

```java
// 方法，IntBinaryOperator是一个接口，并只有一个抽象方法
public static int calNum(IntBinaryOperator operator) {
    int a = 10;
    int b = 20;
    return operator.applyAsInt(a, b);
}

// 使用
public static void main(String[] args) {
	// 常规写法
    calNum(new IntBinaryOperator() {
        @Override
        public int applyAsInt(int left, int right) {
            return left + right;
        }
    });
	// lambda表达式写法
    calNum((int a, int b) -> {
        return a + b;
    });
}
```

#### 例三

```java
// 方法
public static void printNum(IntPredicate predicate) {
    int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    for (int i : arr) {
        if (predicate.test(i)) {
            System.out.println(i);
        }
    }
}
// 使用
public static void main(String[] args) {
	// 匿名内部类写法
    printNum(new IntPredicate() {
        @Override
        public boolean test(int value) {
            return value % 2 == 0;
        }
    });
    // lambda写法
    printNum((int value) -> {
        return value % 2 == 0;
    });
}
```

#### 例四

```java
// 接口
public interface Function<T, R> {
    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
}
// 方法
public static <R> R typeConver(Function<String,R> function){
    String str = "123456";
    R result = function.apply(str);
    return result;
}
// 使用
public static void main(String[] args) {
	// 匿名内部类
    typeConver(new Function<String, Integer>() {
        @Override
        public Integer apply(String s){
            return Integer.valueOf(s);
        }
    });
    // lambda
    typeConver((String s)->{
        return Integer.valueOf(s);
    });
}
```

#### 例五

```java
// 方法
public static void foreachArr(IntConsumer consumer){
    int[] arr = {1,2,3,4,5,6,7,8,9,10};
    for(int i :arr){
        consumer.accept(i);
    }
}
// 使用 lambda
public static void main(String[] args) {
    foreachArr((int value) -> {
        System.out.println(value);
    });
}
```

### 2.4 省略规则

- 参数类型可以省略
- 方法体只有一句代码时，大括号、return、和分号可省略
- 方法只有一个参数时，小括号可省略

```java
foreachArr((int value) -> {
    System.out.println(value);
});

// 省略写法
foreachArr(value -> System.out.println(value));
```



## 3.Stream流

### 3.1 概述

- 对集合、数组进行链状流式的操作

### 3.2 案例数据准备

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode  //便于后期去重
public class Author{
    private Long id;
    private String name;
    private Integer age;
    private String intro;
    private List<Book> books;
}


@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode  //便于后期去重
public class Book {
    private Long id;
    private String name;
    private String category;    //多类型通过逗号拼接
    private Integer score;
    private String intro;
}


private static List<Author> getAuthors() {
        // 数据初始化
        Author author = new Author(1L, "蒙多", 33, "蒙多的故事", null);
        Author author2 = new Author(2L, "呀拉索", 15, "呀拉索的故事", null);
        Author author3 = new Author(3L, "易", 14, "易的故事", null);
        Author author4 = new Author(3L, "易", 14, "易的故事", null);

        // 书籍列表
        List<Book> books1 = new ArrayList<>();
        List<Book> books2 = new ArrayList<>();
        List<Book> books3 = new ArrayList<>();

        books1.add(new Book(1L, "刀的两侧", "哲学，爱情", 88, "一把刀划分爱恨"));
        books1.add(new Book(2L, "一个人不能死在", "个人成长", 99, "讲述真理"));

        books2.add(new Book(3L, "风吹不到的地方", "哲学", 85, "带你的思维领略世界"));
        books2.add(new Book(3L, "风吹不到的地方", "哲学", 85, "带你的思维领略世界"));
        books2.add(new Book(4L, "吹或不吹", "爱情", 56, "时代理解"));

        books3.add(new Book(5L, "你的剑就是我的剑", "爱情", 56, "宽容"));
        books3.add(new Book(6L, "风与剑", "个人传记", 100, "灵魂碰撞"));
        books3.add(new Book(6L, "风与剑", "个人传记", 100, "灵魂碰撞"));

        author.setBooks(books1);
        author2.setBooks(books2);
        author3.setBooks(books3);
        author4.setBooks(books3);

        return new ArrayList<>(Arrays.asList(author, author2, author3, author4));
    }
```



### 3.3 快速入门

#### 3.3.1 需求

打印所有年龄小于18的作家的名字，并去重

#### 3.3.2 实现

```java
List<Author> authors = getAuthors();
authors.stream()    //把集合转换成流
        .distinct()
        .filter(new Predicate<Author>() {
            @Override
            public boolean test(Author author) {
                return author.getAge()<18;
            }
        }).forEach(new Consumer<Author>() {
            @Override
            public void accept(Author author) {
                System.out.println(author.getName());
            }
        });

// lambda
List<Author> authors = getAuthors();
authors.stream()    //把集合转换成流
        .distinct()
        .filter(author -> author.getAge() < 18)
        .forEach(author -> System.out.println(author.getName()));
```



### 3.4 常用操作

#### 3.4.1 创建流

##### 3.4.1.1 单列集合

- `集合对象.stream()`

```java
List<Author> authors = getAuthors();
// 流
Stream<Author> authorStream = authors.stream();
```

##### 3.4.1.2 数组

- `Arrays.stream(数组) 或 Stream.of(数组)`

```java
Integer[] arr = {1,2,3,4,5};
// 流
Stream<Integer> stream1 = Arrays.stream(arr);
Stream<Integer> stream2 = Stream.of(arr);
```

##### 3.4.1.3 双列集合

- 转成单列集合后再创建

```java
Map<String,Integer> map = new HashMap<>();
map.put("蜡笔小新",19);
map.put("黑子",17);
map.put("日向项阳",16);
// 流
Set<Map.Entry<String, Integer>> entries = map.entrySet();
Stream<Map.Entry<String, Integer>> stream = entries.stream();
```



#### 3.4.2 中间操作

##### 3.4.2.1 filter

- 过滤，符合条件的才能继续留在流中

```java
authors.stream()
        .filter(author -> author.getName().length() > 1)
        .forEach(author -> System.out.println(author.getName()));
```

##### 3.4.2.2 map

- 将流中元素进行计算或转换

```java
authors.stream()
        .map(new Function<Author, String>() {   //第二个泛型需要指定，返回的就是这个类型
            @Override
            public String apply(Author author) {
                return author.getName();
            }
        })
        .forEach(System.out::println);

authors.stream()
        .map(Author::getName)
        .forEach(System.out::println);

authors.stream()
        .map(Author::getAge)
        .map(age -> age + 10)
        .forEach(System.out::println);
```

##### 3.4.2.3 distinct

- 去除流中重复的元素
   - 通过Object的equals的方法判断是否是相同对象，要注意重写equals
      - @EqualsAndHashCode

```java
authors.stream()
        .distinct()
        .map(Author::getName)
        .forEach(System.out::println);
```

##### 3.4.2.4 sorted

- 对流中元素进行排序
- 两种sorted：有参、无参
   - 无参：需要流中的元素实现Comparable接口，重写方法
- 升序还是降序可以通过调试得知

```java
// 无参
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode  
public class Author implements Comparable<Author>{
    private Long id;
    private String name;
    private Integer age;
    private String intro;
    private List<Book> books;
	
    @Override
    public int compareTo(Author o) {
        return this.getAge()-o.getAge();
    }
}

authors.stream()
        .distinct()
        .sorted()
        .forEach(author -> System.out.println(author.getAge()));
```

```java
// 有参
authors.stream()
        .distinct()
        .sorted(new Comparator<Author>() {
                @Override
                public int compare(Author o1, Author o2) {
                    return o1.getAge() - o2.getAge();
                }
            })
        .forEach(author -> System.out.println(author.getAge()));

authors.stream()
        .distinct()
        .sorted((o1, o2) -> o1.getAge() - o2.getAge())
        .forEach(author -> System.out.println(author.getAge()));

authors.stream()
        .distinct()
        .sorted(Comparator.comparingInt(Author::getAge))
        .forEach(author -> System.out.println(author.getAge()));
```

##### 3.4.2.5 limit

- 设置流的最大长度，超出的部分将被抛弃

```java
authors.stream()
        .distinct()
        .sorted(Comparator.comparingInt(Author::getAge))
        .limit(2)
        .forEach(author -> System.out.println(author.getAge()));
```

##### 3.4.2.6 skip

- 跳过流中前n个元素，返回剩下的元素

```java
authors.stream()
        .distinct()
        .sorted(Comparator.comparingInt(Author::getAge))
        .skip(1)
        .forEach(author -> System.out.println(author.getAge()));
```

##### 3.4.2.7 flatMap

- 把**一个对象转换成多个对象**作为流中的元素
   - map只能将一个对象转换为一个对象作为流中的元素

```java
authors.stream()
        .flatMap(author -> author.getBooks().stream())
        .distinct()
        .forEach(book -> System.out.println(book.getName()));
```

```java
authors.stream()
        .flatMap(author -> author.getBooks().stream())
        .distinct()
        .flatMap(book -> Arrays.stream(book.getCategory().split(",")))
        .distinct()
        .forEach(System.out::println);
```



#### 3.4.3 终结操作

##### 3.4.3.1 forEach

- 对流中的元素进行遍历操作，通过传入的参数去指定对遍历的元素进行具体什么操作

```java
authors.stream()
        .map(Author::getName)
        .forEach(System.out::println);
```

##### 3.4.3.2 count

- 获取当前流中元素的个数

```java
long count = authors.stream()
                    .flatMap(author -> author.getBooks().stream())
                    .distinct()
                    .count();
```

##### 3.4.3.3 max&min

- 求流中的最值

```java
Optional<Integer> max = authors.stream()
                                .flatMap(author -> author.getBooks().stream())
                                .map(Book::getScore)
                                .max((score1, score2) -> score1 - score2);
System.out.println(max.get());
```

##### 3.4.3.4 collect

##### 3.4.3.5 查找与匹配

##### 3.4.3.6 reduce归并

























































































































